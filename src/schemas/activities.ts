import { z } from "zod";
import  {userReadOnlySchema} from "@/schemas/users.ts";


/**
 * ActivityReadOnlyDTO returned from the backend
 */
export const activitySchema = z.object({
    id: z.coerce.number().int(),
    title: z.string(),
    description: z.string().optional(),

    city: z.string(),
    location: z.string(),
    category: z.string(),

    startDateTime: z.iso.datetime(),
    endDateTime: z.iso.datetime(),

    maxParticipants: z.coerce.number().int(),
    currentParticipants: z.coerce.number().int(),

    creator: userReadOnlySchema,

    insertedAt: z.iso.datetime(),

    isJoinable: z.boolean(),
    hasStarted: z.boolean(),
    hasEnded: z.boolean(),
    isOngoing: z.boolean(),

    timeStatus: z.string(),  // not in use yet
});

export type Activity = z.infer<typeof activitySchema>


/**
 * ActivityCreateDTO (client → backend)
 */
export const activityCreateSchema = z.object({
    title: z.string()
        .trim()
        .min(2, {message: "Title must be between 2 and 200 characters."})
        .max(200, {message: "Title must be between 2 and 200 characters."}),
    description: z.string()
        .trim()
        .min(1, {message: "The Description field is required."})
        .max(1000, {message: "Description must not exceed 1000 characters."}),

    city: z.string()
        .trim()
        .min(1, {message: "The City field is required."})
        .max(100, {message: "City must not exceed 100 characters."}),

    location: z.string()
        .trim()
        .min(1, {message: "The Location field is required."})
        .max(255, {message: "Location must not exceed 255 characters."}),

    category: z.string()
        .trim()
        .min(1, {message: "The Category field is required."})
        .max(100, {message: "Category must not exceed 100 characters."}),

    startDateTime: z.iso.datetime(),
    endDateTime: z.iso.datetime(),

    maxParticipants: z
        .number()
        .int()
        .min(1, {message: "Maximum participants must be between 1 and 100."})
        .max(100, {message: "Maximum participants must be between 1 and 100."})

    // Fields intentionally omitted:
    // - id -> generated by backend
    // - currentParticipants -> starts at 0
    // - creator -> from auth context
    // - timestamps & computed fields -> backend responsibility
});

export type ActivityCreateFields = z.infer<typeof activityCreateSchema>;

/**
 *  Activity – Update model
 *  Partial update (PATCH) - All fields optional
 */
export const activityUpdateSchema = activityCreateSchema.partial();
export type ActivityUpdateFields = z.infer<typeof activityUpdateSchema>;


/**
 *  Generic pagination type for paginated API responses
 */
export type PaginatedResult<T> = {
    data: T[];
    totalRecords: number;
    pageNumber: number;
    pageSize: number;
};

// PaginatedResult<Activity>;
// PaginatedResult<UserReadOnly>;


/**
 * ActivityFiltersDTO
 */
export type ActivityFilters = {
    title?: string;
    category?: string;
    city?: string;
    location?: string;
    isJoinable?: boolean;
    hasStarted?: boolean;
    hasEnded?: boolean;
    upcomingOnly?: boolean;
    pastOnly?: boolean;
};


/**
 * ActivityParticipantReadOnlyDTO
 */
export const activityParticipantSchema = z.object({
    id: z.coerce.number().int(),
    userId: z.coerce.number().int(),
    username: z.string().optional(),

    activityId: z.number(),
    activityTitle: z.string().optional(),
    activityStartDateTime: z.iso.datetime(),
    joinDate: z.iso.datetime(),
});

export type ActivityParticipant = z.infer<typeof activityParticipantSchema>;


/**
 * ActivityHasJoinedDTO - user-aware
 * Extension of ActivityReadOnlyDTO
 */
export type ActivityHasJoined = Activity & {
    hasJoined: boolean;
};



